<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>PB Senior Design</title>
	<!-- midi.js css -->
	<link href="./css/bootstrap.min.css" rel="stylesheet" type="text/css" />
	<link href="./css/MIDIPlayer.css" rel="stylesheet" type="text/css" />


	<script src="js/three.min.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="js/jquery-3.1.1.min.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script src="js/bootstrap.min.js" type="text/javascript"></script>

	<!-- shim -->
	<script src="MIDI.js/inc/shim/Base64.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/Base64binary.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/WebAudioAPI.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/WebMIDIAPI.js" type="text/javascript"></script>
	<!-- jasmid package -->
	<script src="MIDI.js/inc/jasmid/stream.js"></script>
	<script src="MIDI.js/inc/jasmid/midifile.js"></script>
	<script src="MIDI.js/inc/jasmid/replayer.js"></script>
	<!-- midi.js package -->
	<script src="MIDI.js/js/midi/audioDetect.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/gm.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/loader.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.audiotag.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.webaudio.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.webmidi.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/player.js" type="text/javascript"></script>
	<!-- utils -->
	<script src="MIDI.js/js/util/dom_request_xhr.js" type="text/javascript"></script>
	<script src="MIDI.js/js/util/dom_request_script.js" type="text/javascript"></script>
	<!-- includes -->
	<script src="MIDI.js/examples/inc/timer.js" type="text/javascript"></script>
	<script src="MIDI.js/examples/inc/colorspace.js" type="text/javascript"></script>
	<script src="MIDI.js/examples/inc/event.js" type="text/javascript"></script>

</head>
<body>
	<div id="colors"></div>
	<div>
		<div class="player" style="z-index:4;">
			<div style="margin: 0 auto; width: 160px; float: right;">
				<input type="image" src="images/pause.png" align="absmiddle" value="pause" onclick="pausePlayStop()" id="pausePlayStop">
				<input type="image" src="images/stop.png" align="absmiddle" value="stop" onclick="pausePlayStop(true)">
				<input type="image" src="images/backward.png" align="absmiddle" value="stop" onclick="player.getNextSong(-1);">
				<input type="image" src="images/forward.png" align="absmiddle" value="stop" onclick="player.getNextSong(+1);">
			</div>
			<div class="time-controls">
				<span id="time1" class="time">0:00</span>
				<span id="capsule">
					<span id="cursor"></span>
				</span>
				<span id="time2" class="time" style="text-align: left;">-0:00</span>
			</div>
		</div>
		<!-- <div id="channels"></div> -->
		<div id="colorController">
			<div id="sliders">
				<label class="angleInputLabel">Outer</label>
				<input type="range" min="0" max="360" class="angleInput" id="primaryAngle"><br>
				<label class="angleInputLabel">Inner</label>
				<input type="range" min="0" max="360" class="angleInput" id="secondaryAngle">
				<div id="ringButtons">
					<div class="btn-group btn-group-xs" role="group" aria-label="...">
						<button type="button" class="btn btn-default" onclick="resetColorWheel(fifthsOrder)">Circle of Thirds</button>
						<button type="button" class="btn btn-default" data-toggle="modal" data-target="#customOuterRingModal" onclick="pausePlayStop()">Custom</button>
						<button type="button" class="btn btn-success" onclick="startAnimation()">GO</button>
						<input type='file' accept='audio/midi' onchange='openFile(event)'><br>
						<img id='output'>
					</div>
				</div>
			</div>
			<img id="colorwheel" src="images/colorwheel_hsl.png">
			<div id="blender"></div>

			<!-- <img id="fifthswheel" src="images/circle_fifths_wheel.png"> -->
		</div>
	</div>
	<div class="modal bs-example-modal-sm" id="customOuterRingModal" tabindex="-1" role="dialog" aria-labelledby="mySmallModalLabel">
			  <div class="modal-dialog modal-sm" role="document">
			    <div class="modal-content">
			      <div class="modal-header">
			        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
			        <h4 class="modal-title" id="myModalLabel">Custom Note Order</h4>
			      </div>
			      <div class="modal-body">
			      	<div class="col-xs-5" id="sortableTip">
			      		<p>Drag notes to re-order</p><br>
			      		<label><input type="checkbox" id="outerCheckbox" value="outer_checkbox" checked> Outer Ring</label><br>
			      		<label><input type="checkbox" id="innerCheckbox" value="inner_checkbox" checked> Inner Ring</label><br>
			      	</div>
			      	<div class="col-xs-5">
				      	<ul id="sortable">
								  <li id="0" class="sortNote">C</li>
								  <li id="1" class="sortNote">C#/Db</li>
								  <li id="2" class="sortNote">D</li>
								  <li id="3" class="sortNote">D#/Eb</li>
								  <li id="4" class="sortNote">E</li>
								  <li id="5" class="sortNote">F</li>
								  <li id="6" class="sortNote">F#/Gb</li>
								  <li id="7" class="sortNote">G</li>
								  <li id="8" class="sortNote">G#/Ab</li>
								  <li id="9" class="sortNote">A</li>
								  <li id="10" class="sortNote">A#/Bb</li>
								  <li id="11" class="sortNote">B</li>
								</ul>
							</div>
							<div class="col-xs-2">
								<img id="sortableGradient" src="images/colorGradient.png">
							</div>
			      </div>
			      <div class="modal-footer">
			        <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">Close</button>
			        <button type="button" class="btn btn-primary btn-sm" onclick="customRing()">Save</button>
			      </div>
			    </div>
			  </div>
			</div>
	<div id="canvas"></div>

<script type="text/javascript">
	if (typeof (console) === "undefined") var console = {
		log: function() {}
	};

	$( function() {
    $( "#sortable" ).sortable();
    $( "#sortable" ).disableSelection();
  } );

	// Threejs
	var scene, camera, renderer, noteVertices, vertexColors, vertexKey, vertexColorCache, gColorMap;

	// camera movement
	var ticksPerBeat = 0;
	var animating = false;

	var primaryColors, secondaryColors;

	var primaryHolder, secondaryHolder;

	var fifthsOrder = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];
	var currentNoteOrder = fifthsOrder;

		var secondaryColors = { //offset by half from primary for testing
			
			0: [ 270, 100, 50 ], // 9 A
			1: [ 120, 100, 60 ], // 4 E
			2: [ 330, 100, 46 ], // 11 B 
			3: [ 180, 100, 34 ], // 6 Gb
			4: [ 30, 100, 51 ], // 1 Db
			5: [ 240, 100, 27 ], // 8 Ab
			6: [ 90, 100, 60 ], // 3 Eb
			7: [ 300, 100, 37 ], // 10 Bb
			8: [ 150, 100, 32 ], // 5 F
			9: [ 0, 100, 51 ], // 0 C
			10: [ 210, 100, 28 ], // 7 G
			11: [ 60, 100, 52 ] // 2 D
		};

	function loadRemote(path, callback) {
			var fetch = new XMLHttpRequest();
			fetch.open('GET', path);
			fetch.overrideMimeType("text/plain; charset=x-user-defined");
			fetch.onreadystatechange = function() {
				if(this.readyState == 4 && this.status == 200) {
					/* munge response into a binary string */
					var t = this.responseText || "" ;
					var ff = [];
					var mx = t.length;
					var scc= String.fromCharCode;
					for (var z = 0; z < mx; z++) {
						ff[z] = scc(t.charCodeAt(z) & 255);
					}
					callback(ff.join(""));
				}
			}
			fetch.send();
		}


	function setup() {
		noteVertices = new Array(7);
		for (var i = 0; i < 7; i++) {
		  	noteVertices[i] = new Array(6);
		}
		var noteOrder = [7, 11, 3, 2, 6, 10, 9, 1, 5];
		var nIdx = 0;

		for (var x = 0; x < 3; x++) {
			for (var y = 0; y < 3; y++) {
				var note = noteOrder[nIdx];
				noteVertices[x][y] = note;
				noteVertices[x][y + 3] = note;
				noteVertices[x + 4][y + 2] = note;
				noteVertices[x + 4][(y + 5) % 6] = note;
				nIdx++;
			}
		}
		noteVertices[3][0] = 4;
		noteVertices[3][3] = 4;
		noteVertices[3][1] = 8;
		noteVertices[3][4] = 8;
		noteVertices[3][2] = 0;
		noteVertices[3][5] = 0;

		vertexKey = [];
	}

	setup();

	////// D3 Rotating input functionality
	var wheelWidth = 200;
	var wheelHeight = 200;
	var wheelX = 0;
	var wheelY = 0;

	primaryHolder = d3.select("body")
	.append("svg")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("class", "colorInput");

	primaryHolder.append("image")
	.attr("xlink:href", "images/circle_fifths_wheel.png")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("x", wheelX)
	.attr("y", wheelY);

	secondaryHolder = d3.select("body")
	.append("svg")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("class", "colorInput");

	secondaryHolder.append("image")
	.attr("xlink:href", "images/circle_fifths_wheel_minor.png")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("x", wheelX)
	.attr("y", wheelY);


	// when the input range changes update the angle 
	d3.select("#primaryAngle").on("input", function() {
		updateAngle(+this.value, 0);
	});

	d3.select("#secondaryAngle").on("input", function() {
		updateAngle(+this.value, 1);
	});


	updateAngle(0,0);
	updateAngle(0,1);
	// set default colors
	resetColorWheel(fifthsOrder);


function init() {
	resetColorWheel(fifthsOrder);
	scene = new THREE.Scene();
	var WIDTH = 0.8*window.innerWidth,
	    HEIGHT = window.innerHeight;

	container = document.getElementById('canvas');
	document.body.appendChild( container );

	renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(WIDTH, HEIGHT);
	container.appendChild( renderer.domElement );

  camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
  camera.position.set(532, -500, 100);
//     {x: 0.06789925799970922, y: 0.8399987615915472, z: -0.5383231084649841}
// (index):247 q {x: 532.3324120127733, y: -505.8011184302427, z: 413.26422056914737}
	camera.up = new THREE.Vector3(0,0,1);
  var dir = new THREE.Vector3(0.86789925799970922, 0.8399987615915472, -0.5383231084649841);
  var pos = new THREE.Vector3(532, -505, 413);
	camera.lookAt(140,100,0);

  scene.add(camera);
  

  window.addEventListener('resize', function() {
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;
    renderer.setSize(WIDTH, HEIGHT);
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();
  });

  var light = new THREE.PointLight(0xffffff);
  light.position.set(-100,200,100);
  scene.add(light);

 	var geometry = new THREE.Geometry(); 

 	var colorMap = mapColorsToVertices();

	var material = new THREE.MeshBasicMaterial( { 
		    shading: THREE.FlatShading,
		    vertexColors: THREE.VertexColors,
		    wireframe: true
		});

	var solidMaterial = new THREE.MeshBasicMaterial({
        polygonOffset: true,  
        polygonOffsetUnits: 1,
        polygonOffsetFactor: 1,
        shading: THREE.FlatShading,
        vertexColors: THREE.FaceColors
    });


	var srcmidifile = 'music/fur_elise.mid';

	loadRemote(srcmidifile, function(data) {
			mfile = MidiFile(data);

			var midiGeometry = buildSongStructure(mfile);
			var pointMaterial = new THREE.PointsMaterial( { 
				vertexColors: THREE.VertexColors,
				visible: true, 
				size: 10 } )
			var dot = new THREE.Points( midiGeometry.notes, pointMaterial );
			scene.add( dot );

			var meshMaterial = new THREE.MeshBasicMaterial( { 
				    shading: THREE.FlatShading,
				    vertexColors: THREE.VertexColors,
				    wireframe: true
				});
			for (var i = 0; i < midiGeometry.tonnetz.length; i++) {
				var tonnetzMesh = new THREE.Mesh(midiGeometry.tonnetz[i], meshMaterial);
				scene.add(tonnetzMesh);
			}
			
			// scene.add(cube);
			// mesh.name = "tonnetz";
			// scene.add(mesh);
			animate();


	});
/*
 	var geometry = buildTonnetzGeometry(colorMap, true);

 	var solidGeometry = buildTonnetzGeometry(colorMap, false);

	var mesh = new THREE.Mesh( geometry, material );

	mesh.name = "tonnetz";
	scene.add(mesh);

	var solidMesh = new THREE.Mesh( solidGeometry, solidMaterial );
	solidMesh.name = "solidMesh";
	scene.add(solidMesh)

	cacheVertexColors(mesh);
*/

 	controls = new THREE.OrbitControls(camera, renderer.domElement);
}

function animate() {
	requestAnimationFrame(animate);
	var d = new Date();
	console.log(d.getTime());
	if (animating) {
		camera.position.z += ticksPerBeat;
	}
 	
  // Render the scene.
  renderer.render(scene, camera);
  controls.update();

}

// cache vertex hues
function cacheVertexColors(mesh) {
	vertexColorCache = [];
	for (var f = 0; f < mesh.geometry.faces.length; f++) {
		var faceCol = mesh.geometry.faces[ f ].vertexColors[ 0 ].getHSL();
		var h = faceCol.h * 360;
		vertexColorCache.push(h);
	}
}

function updateMesh(mesh, colorOffset) {
	
	if (colorOffset != 0) {
		var cacheCopy = vertexColorCache.slice();

		// 
		for (var i = 0; i < cacheCopy.length; i++) {
			cacheCopy[i] = (cacheCopy[i] + colorOffset) % 360;
			cacheCopy[i] /= 360.0;
		}
		var cIdx = 0;
		for (var f = 0; f < mesh.geometry.faces.length; f++) {
			mesh.geometry.faces[ f ].vertexColors[ 0 ].setHSL(cacheCopy[cIdx], 1.0, 0.5);
			cIdx++;
		}

		mesh.geometry.colorsNeedUpdate = true;
		// animate();
	}
	
}

function buildTonnetzGeometry(colorMap, hasVertexColors) {
	var geometry = new THREE.Geometry();
   	vertexColors = [];
   	vertexKey = [];

   	for (var y = 0; y < 6; y++) {
   		for (var x = 0; x < 7; x++) {
   			var vertex = new THREE.Vector3(100*x + 50*y, 500 - (100*y), 0);
   			geometry.vertices.push(vertex);
   			vertexKey.push(noteVertices[x][y]);
   			var col = HSLArrayToString(colorMap[x][y]);
   			var vertColor = new THREE.Color( col );
   			vertexColors.push(vertColor);
   		}
   	}

   	for (var v = 0; v < geometry.vertices.length - 1; v++) {
   		// first row
   		if ( v < 6 ) {
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			if (hasVertexColors) {
   				face1.vertexColors[0] = vertexColors[v];
					face1.vertexColors[1] = vertexColors[v+1];
					face1.vertexColors[2] = vertexColors[v+7];
   			}
   			else {
   				face1.color.setHSL(0, 0, 0.3);
   			}
   			

				geometry.faces.push( face1 );
   		}
   		// middle rows
   		else if (( v > 6 && v < 13 ) || (v > 13 && v < 20) || (v > 20 && v < 27) || (v > 27 && v < 34)) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face0.vertexColors[0] = vertexColors[v-6];
					face0.vertexColors[1] = vertexColors[v+1];
					face0.vertexColors[2] = vertexColors[v];
				}
				else {
   				face0.color.setHSL(0, 0, 0.3);
   			}

   			geometry.faces.push( face0 );
   			
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face1.vertexColors[0] = vertexColors[v];
					face1.vertexColors[1] = vertexColors[v+1];
					face1.vertexColors[2] = vertexColors[v+7];
				}
				else {
   				face1.color.setHSL(0, 0, 0.3);
   			}

				geometry.faces.push( face1 );
		}
   		else if (v > 34 && v < 41) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face0.vertexColors[0] = vertexColors[v-6];
					face0.vertexColors[1] = vertexColors[v+1];
					face0.vertexColors[2] = vertexColors[v];
				}
				else {
   				face0.color.setHSL(0, 0, 0.3);
   			}

   			geometry.faces.push( face0 );
   		}
   		else {
   			continue;
   		}
   	}
   	return geometry;
}

function mapColorsToVertices(colorset) {
	if (!colorset) { // default
		colorset  = primaryColors;
	}

	var colorMap = new Array(7);
	for (var i = 0; i < 7; i++) {
	  	colorMap[i] = new Array(6);
	}

	for (var x = 0; x < 7; x++) {
		for (var y = 0; y < 6; y++) {
			var note = noteVertices[x][y];
			colorMap[x][y] = colorset[note];
		}
	}
	gColorMap = colorMap;
	return colorMap;
}


// update the element
function updateAngle(angle, id) {

	if (id == 0) {
		// adjust the text on the range slider
		d3.select("#primaryAngle").property("value", angle);

		// rotate the text
		primaryHolder.select("image") 
		.attr("transform", "rotate(" + angle + "," + (wheelX + wheelWidth/2) + ","+ (wheelY+wheelHeight/2) +")")

	} else {
		d3.select("#secondaryAngle").property("value", angle);
		secondaryHolder.select("image") 
		.attr("transform", "rotate(" + angle + "," + (wheelX + wheelWidth/2) + ","+ (wheelY+wheelHeight/2) +")")
	}
}


function setColors(noteOrder) {
		var dAngle = 360/noteOrder.length;
		var colorMap = {};
		for (var n = 0; n < noteOrder.length; n++) {
			var hue = n*dAngle;
			colorMap[noteOrder[n]] = [hue, 100, 50];
		}
		return colorMap;
	}

function resetColors(noteOrder) {
	primaryColors = setColors(noteOrder);
	secondaryColors = {};
	for (var i = 0; i < 12; i++) {
		secondaryColors[i] = primaryColors[(i + 3) % 12].slice();
	}
}

function resetColorWheel(noteOrder) {
	resetColors(noteOrder);
	primaryHolder.select("image")
	.attr("xlink:href", "images/circle_fifths_wheel.png")
	secondaryHolder.select("image")
	.attr("xlink:href", "images/circle_fifths_wheel_minor.png")
	updateAngle(0, 0);
	updateAngle(15, 1);
}

// set individual ring and return to 0 rotation
function setColorRing(noteOrder, ring) {
	if (ring == 0) { // primary
		primaryColors = setColors(noteOrder);
		updateAngle(0, 0);
	}
	else { // secondary
		secondaryColors = setColors(noteOrder);
		updateAngle(0, 1);
	}
}

function customRing() {
	var sortedNotes = $( "#sortable" ).sortable( "toArray" );
	var customNoteOrder = [];
	var cRotate = 0;
	for (var i = 0; i < sortedNotes.length; i++) {
		customNoteOrder.push(parseInt(sortedNotes[i]));
		if (parseInt(sortedNotes[i]) == 0) {
			cRotate = i;
		}
	}
	this.currentNoteOrder = customNoteOrder;

	if($("#outerCheckbox").is(':checked')) {
		primaryHolder.select("image")
		.attr("xlink:href", "images/custom_wheel/co"+ cRotate +".png")

		setColorRing(customNoteOrder, 0);

		if ($("#innerCheckbox").is(':checked')) {

			secondaryHolder.select("image")
			.attr("xlink:href", "images/custom_wheel/ci"+ cRotate +".png")

		  setColorRing(customNoteOrder, 1);
		}
	}    
	else if ($("#innerCheckbox").is(':checked')) {

	  secondaryHolder.select("image")
			.attr("xlink:href", "images/custom_wheel/ci"+ cRotate +".png")
		  setColorRing(customNoteOrder, 1);
	}
	else {
		alert('No ring specified! Reverting to default.');
		resetColorWheel(fifthsOrder);
	}
}

// Toggle between Pause and Play modes.
function pausePlayStop(stop) {
	var d = document.getElementById("pausePlayStop");
	if (stop) {
		MIDI.Player.stop();
		d.src = "images/play.png";
	} else if (MIDI.Player.playing) {
		d.src = "images/play.png";
		MIDI.Player.pause(true);
	} else {
		d.src = "images/pause.png";
		MIDI.Player.resume();
	}
};
eventjs.add(window, "load", function(event) {

	var colors = document.getElementById("colors");
	var colorElements = [];
	var activeNotes = [];
	for (var n = 0; n < 88; n++) {
		var d = document.createElement("div");
		d.className = "keyColor"
		d.innerHTML = MIDI.noteToKey[n + 21];
		var col = parseInt(255 - ((255 / 88) * n));
		var stringNum = col.toString(16);
		if (col < 16) {
			stringNum = "0" + stringNum;
		}
		colorElements.push(d);
		colors.appendChild(d);
		activeNotes.push(0);
	}

	MIDI.loader = new sketch.ui.Timer;
	MIDI.loadPlugin({
		soundfontUrl: "MIDI.js/examples/soundfont/",
		onprogress: function(state, progress) {
			MIDI.loader.setValue(progress * 100);
		},
		onsuccess: function() {
			/// this is the language we are running in
			/// this sets up the MIDI.Player and gets things going...
			player = MIDI.Player;
			// var channels = [];
			// var channelCount = 0;
			// var channelContainer = document.getElementById("channels");
			// for (var channel in MIDI.channels) {
			// 	var chanDiv = document.createElement("div");
			// 	chanDiv.className = "channel"
			// 	chanDiv.id = "channel" + channelCount;
			// 	chanDiv.innerHTML = "channel " + channelCount;
			// 	channelCount++;
			// 	channelContainer.appendChild(chanDiv);
			// 	channels.push(chanDiv);
			// }
			player.timeWarp = 1; // speed the song is played back
			player.loadFile(song[songid++ % song.length], player.start);
			player.stop();
			// fetch primary and secondary angles
			var pAngleOffset = parseInt(d3.select("#primaryAngle").property("value"));
			var sAngleOffset = parseInt(d3.select("#secondaryAngle").property("value"));

			var offsetColors = getOffsetColors(pAngleOffset, sAngleOffset);
			var allColors = getColorMap(offsetColors);
			var blendBox = document.getElementById("blender");
			// var mesh = scene.getObjectByName( "tonnetz" );

			var numNotes = 0;
			player.addListener(function(data) {

				var currPOffset = parseInt(d3.select("#primaryAngle").property("value"));
				var currSOffset = parseInt(d3.select("#secondaryAngle").property("value"));

				// if user changes color shift
				if (currPOffset != pAngleOffset || currSOffset != sAngleOffset) {
					pAngleOffset = currPOffset;
					sAngleOffset = currSOffset;
					getOffsetColors(pAngleOffset, sAngleOffset);
					allColors = getColorMap();
					// updateMesh(mesh, pAngleOffset);
				}

				var note = data.note - 21;
				var d = colorElements[note];
				var colorset;
				if (d) {
					if (data.message === 144) {
						numNotes++;
						if (numNotes > 1) {
							colorset = allColors.secondary;
						}
						else {
							colorset = allColors.primary;
						}
						d.style.background = HSLArrayToString(colorset[note]);
						activeNotes[note] = colorset[note];
						// displaceVertex(note, data.velocity);
					} else {
						numNotes--;
						numNotes = Math.max(numNotes, 0);
						if (numNotes > 0) {
							colorset = allColors.secondary;
						}
						else {
							colorset = allColors.primary;
						}
						d.style.background = "";
						activeNotes[note] = 0;
						// displaceVertex(note, data.velocity);
					}

					var blendColor;
					blendColor = blendColors(activeNotes);
					blendBox.style.background = HSLArrayToString(blendColor);
					// colorSolidMesh(blendColor);
					// updateMesh(mesh, pAngleOffset);
				}

			});
			///
			MIDIPlayerPercentage(player);
		}
	});
});

function colorSolidMesh(blendColor) {
	if (!blendColor) {
		blendColor = [0, 0, 30];
	}
	var mesh = scene.getObjectByName("solidMesh");
	var h = blendColor[0] / 360.0;
	var s = blendColor[1] / 100.0;
	var l = blendColor[2] / 100.0;
	for (var f = 0; f < mesh.geometry.faces.length; f++) {
		mesh.geometry.faces[ f ].color.setHSL(h, s, l);
	}
	mesh.geometry.colorsNeedUpdate = true;
}

// highlight active notes
function highlightVertices(activeColors, blendColor, colorset) {
	// copy colorset, appparently this is the fastest way
	var cs = JSON.parse(JSON.stringify(colorset)); 
	if (blendColor[0] < 0) {
		blendColor[0] = (360 + blendColor[0]);
	}
	blendColor[0] = parseInt(blendColor[0]);
	blendColor[1] = parseInt(blendColor[1]);
	blendColor[2] = parseInt(blendColor[2]);

	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			cs[(i + 9) % 12] = blendColor;
		}
	}
	return cs;
}

function displaceVertex(note, dz) {
	var n = ((note + 9) % 12);

	var mesh = scene.getObjectByName( "tonnetz" );
	var solidMesh = scene.getObjectByName("solidMesh");

	for (var v = 0; v < vertexKey.length; v++) {
		if (vertexKey[v] == n) {
			var oldVert = mesh.geometry.vertices[v];

			mesh.geometry.vertices[v].set(oldVert.x, oldVert.y, dz);
			mesh.geometry.dynamic = true;
			mesh.geometry.verticesNeedUpdate = true;

			solidMesh.geometry.vertices[v].set(oldVert.x, oldVert.y, dz);
			solidMesh.geometry.dynamic = true;
			solidMesh.geometry.verticesNeedUpdate = true;
		}
	}

}


function buildDisplacementMap(activeColors) {
	var dz = 100;
	var dMap = new Array(7);
	for (var i = 0; i < 7; i++) {
	  	dMap[i] = new Array(6).fill(0);
	}

	var notesToMove = [];
	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			var note = (i + 9) % 12;
			notesToMove.push(note);
		}
	}

	for (var n = 0; n < notesToMove.length; n++) {
		for (var x = 0; x < 7; x++) {
			for (var y = 0; y < 6; y++) {
				if (noteVertices[x][y] == notesToMove[n]) {
					dMap[x][y] = dz;
				}
			}
		}
	}

	return dMap;
}


// blend multiple colors together - raw average
function blendColors(activeColors) {
	var toBlend = [];
	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			toBlend.push(col);
		}
	}
	var numColors = toBlend.length;
	if (!numColors) return "";

	// convert from polar (HSL) coordinates to average color
	var colY = 0;
	var colX = 0;

	var avgS = 0;
	var avgL = 0;

	for (var color = 0; color < numColors; color++) {
		var colorAngle = toBlend[color][0] * Math.PI / 180; // convert to radians
		colY += Math.sin(colorAngle);
		colX += Math.cos(colorAngle);
		avgS += toBlend[color][1];
		avgL += toBlend[color][2];
	}

	var magnitude = Math.sqrt(Math.pow(colY, 2) + Math.pow(colX, 2));
	magnitude /= numColors; // normalize by potential longest length (all tones coincident)
	avgS = Math.min(magnitude*100, 100);
	avgL /= numColors;

	var avgRadAngle = Math.atan2(colY, colX); // new color direction
	var avgColor = avgRadAngle * 180/Math.PI; // convert back to degrees (hue)

	// format for hsl
	var blendedColor = [avgColor, avgS, avgL];
	return blendedColor;
}

function getOffsetColors(pOffset, sOffset) {
	resetColors(currentNoteOrder);
	// add offset
	for (var c = 0; c < 12; c++) {
		var col = primaryColors[c];
		col[0] = (col[0] + pOffset) % 360;
		primaryColors[c] = col;

		var scol = secondaryColors[c];
		scol[0] = (scol[0] + sOffset) % 360;
		secondaryColors[c] = scol;
	}

	var allColors = {};
	allColors.primary = primaryColors;
	allColors.secondary = secondaryColors;
	return allColors;
}

function getColorMap() {
	var primaryNoteColors = {};
	var secondaryNoteColors = {};
	for (var note = 0; note < 88; note++) {

		var pCol = primaryColors[(note + 9) % 12];
		primaryNoteColors[note] = pCol;

		var sCol = secondaryColors[(note + 9) % 12];
		secondaryNoteColors[note] = sCol;
	}

	var allColors = {};
	allColors.primary = primaryNoteColors;
	allColors.secondary = secondaryNoteColors;

	return allColors;
}


function HSLArrayToString(col) {
	if (Array.isArray(col) && col.length == 3) {
		return 'hsl(' + col[0] + ',' + col[1] + '%,' + col[2] + '%)';
	}
	else {
		return 'hsl(0, 0%, 0%)';
	}
}

var numSongs = 0;
var openFile = function(event) {
  var input = event.target;

  var reader = new FileReader();
  reader.onload = function(){
    var dataURL = reader.result;
    var output = document.getElementById('output');
    output.src = dataURL;
    song = [];
    song.push(dataURL);
    console.log(song);
    numSongs++;
  };
  reader.readAsDataURL(input.files[0]);
};

function MIDIPlayerPercentage(player) {
	// update the timestamp
	var time1 = document.getElementById("time1");
	var time2 = document.getElementById("time2");
	var capsule = document.getElementById("capsule");
	var timeCursor = document.getElementById("cursor");
	//
	eventjs.add(capsule, "drag", function(event, self) {
		eventjs.cancel(event);
		player.currentTime = (self.x) / 420 * player.endTime;
		if (player.currentTime < 0) player.currentTime = 0;
		if (player.currentTime > player.endTime) player.currentTime = player.endTime;
		if (self.state === "down") {
			player.pause(true);
		} else if (self.state === "up") {
			player.resume();
		}
	});
	
	function timeFormatting(n) {
		var minutes = n / 60 >> 0;
		var seconds = String(n - (minutes * 60) >> 0);
		if (seconds.length == 1) seconds = "0" + seconds;
		return minutes + ":" + seconds;
	};
	player.getNextSong = function(n) {
		var id = Math.abs((songid += n) % song.length);
		player.loadFile(song[id], player.start); // load MIDI
	};
	player.setAnimation(function(data, element) {
		var percent = data.now / data.end;
		var now = data.now >> 0; // where we are now
		var end = data.end >> 0; // end of song
		if (now === end) { // go to next song
			var id = ++songid % song.length;
			player.loadFile(song[id], player.start); // load MIDI
		}
		// display the information to the user
		timeCursor.style.width = (percent * 100) + "%";
		time1.innerHTML = timeFormatting(now);
		time2.innerHTML = "-" + timeFormatting(end - now);
	});
};

// function animatePlayer(id) {
// 	document.getElementById(id).animate([
// 	  // keyframes
// 	  { transform: 'translateX(0px)' }, 
// 	  { transform: 'translateX(1000px)' }
// 	  ], { 
// 	  // timing options
// 	  duration: 1000,
// 	  iterations: 1
// 	});
// };
		// Begin loading indication.
		var player;
		// MIDI files from Disklavier World
		var songid = 0;
		var song = [
	// Test 1
	 'data:audio/mid;base64,TVRoZAAAAAYAAQABAMBNVHJrAAAARwD/WAQEAhgIAP9RAwehIAD/AwlOZXcgVHJhY2sAwHMAkDxkMoA8MIEOkDxkMoA8MIEOkDxkMoA8MIEOkDxkgT+APDAB/y8A',
	// Test 2
	// 'data:audio/mid;base64,TVRoZAAAAAYAAQABAMBNVHJrAAAAVwD/WAQEAhgIAP9RAwehIAD/AwlOZXcgVHJhY2sAwAAAkDxkgRCAPDAwkDxkgRCAPDAwkDxkAJBAZACQQ2SBEIA8MACAQDAAgEMwMJA8ZIE/gDwwJv8vAA==',
	// Test 3
//		'data:audio/mid;base64,TVRoZAAAAAYAAQABAMBNVHJrAAAAXwD/WAQEAhgIAP9RAwehIAD/AwlOZXcgVHJhY2sAwAAAkDxkgRCAPDAwkDxkgRCAPDAwkDxkAJBAZACQQ2QHkEhkgQmAPDAAgEAwAIBDMACASDAwkDxkgT+APDAm/y8A',

	//'data:audio/mid;base64,TVRoZAAAAAYAAQACAeBNVHJrAAAAnwD/Awh1bnRpdGxlZAD/AihDb3B5cmlnaHQgKGMpIDIwMTIgUHJvc29uaWMgU3R1ZGlvcywgTExDAP9YBAwDDAgA/1kCAAAA/1EDCSfAAP8GBUkgMm5khVD/BgQtVklJkHD/BgZ2aSAxc3SFUP8GBC1WSUmQcP8GBUkgMm5khVD/BgQtVklJkHD/BgZ2aSAxc3SFUP8GBVYgMXN0AP8vAE1UcmsAAADNAP8DLFRyaWFkc15NYWpvcl4xMi04XkkgLVZJSSB2aSAtVklJIEkgLVZJSSB2aSBWAZBAeQBEeQI7eoVCOwAARAAAQAAHRWsEPm4BQm6QZEIAAD4AAEUAB0l0AUB2AUR2hUdEAABAAABJAAdFawRCbgM+cJBiPgAAQgAARQAKO3cBQHgDRHqFQkQAAEAAADsABUJpAUVqAT5rkGk+AABFAABCAAZJdABEdAhAeoVCQAAARAAASQAIP2sCR20BQm6QZUIAAEcAAD8AAP8vAA==',
	];

// construct template tonnetz geometry
function buildTemplateTonnetzGeometry(time) {
	var geometry = new THREE.Geometry();
   	vertexColors = [];
   	vertexKey = [];

   	var mag = 40;
   	for (var y = 0; y < 6; y++) {
   		for (var x = 0; x < 7; x++) {
   			var vertex = new THREE.Vector3(mag*x + mag*0.5*y, mag*5 - (mag*y), time);
   			geometry.vertices.push(vertex);
   			vertexKey.push(noteVertices[x][y]);
   			var col = HSLArrayToString(gColorMap[x][y]);
   			var vertColor = new THREE.Color( col );
   			vertexColors.push(vertColor);
   		}
   	}

   	for (var v = 0; v < geometry.vertices.length - 1; v++) {
   		// first row
   		if ( v < 6 ) {
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
 				face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];
   			

				geometry.faces.push( face1 );
   		}
   		// middle rows
   		else if (( v > 6 && v < 13 ) || (v > 13 && v < 20) || (v > 20 && v < 27) || (v > 27 && v < 34)) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];

   			geometry.faces.push( face0 );
   			
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];


				geometry.faces.push( face1 );
		}
   		else if (v > 34 && v < 41) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];


   			geometry.faces.push( face0 );
   		}
   		else {
   			continue;
   		}
   	}
  return geometry;
}


// convert array to threejs vertices for point cloud rendering
function createGeometry(noteArray, startTime, totalTime) {
	var geometry = new THREE.Geometry();
	var tonnetzGeo = [];
	var zidx = 0;
	var notes;
	var result = {};
 	// for (var eventTime in noteArray) {
 	for (var t = startTime; t < totalTime; t++) {
 		if (noteArray[t]) {
 			notes = noteArray[t];
 			var singleTon = buildTemplateTonnetzGeometry(t);
 			tonnetzGeo.push(singleTon);
 		}
 		if (!notes) continue;
		// var notes = noteArray[eventTime];
		for (var n = 0; n < notes.length; n++) {
			var note = notes[n];
 			for (var x = 0; x < 7; x++) {
				for (var y = 0; y < 6; y++) {
					if (noteVertices[x][y] == (note % 12)) {
						octaveShift = (Math.floor(note / 12) * 280) - (280*3.5);
						octaveShift = 0;
						var vertex = new THREE.Vector3(40*x + 20*y + octaveShift, 200 - (40*y), t - startTime);
						// var vertex = new THREE.Vector3(x, y, 0);
						geometry.vertices.push(vertex);
						var col = HSLArrayToString(primaryColors[note % 12]);
   					var vertColor = new THREE.Color( col );
   					geometry.colors.push(vertColor);
					}
				}
			}
 		}
 		zidx += 50;
 	}
 	result.notes = geometry;
 	result.tonnetz = tonnetzGeo;

 	return result;
}

// construct main structure of song
function buildSongStructure(midifile) {
	var header = midifile.header;
	var tracks = midifile.tracks;

	ticksPerBeat = header.ticksPerBeat;

	var events = tracks[1];

	var totalTime = 0;
	var notesForStruct = {};
	var currentNotes = [];
	var startTime = -1;

	// if event contains 'noteOn' or 'noteOff' subtypes, add note to an object for each time that an event occurs
	for (var e = 0; e < events.length; e++) {
		var noteEvent = events[e];
		if (noteEvent.type != "channel" || (noteEvent.subtype != "noteOn" && noteEvent.subtype != "noteOff")) continue;
		totalTime += noteEvent.deltaTime;
		var note = (noteEvent.noteNumber + 9);
		if (noteEvent.subtype == "noteOn") {
			currentNotes.push(note);
			if (startTime == -1) startTime = totalTime;
		}
		else if(noteEvent.subtype == "noteOff") {
			var idx = currentNotes.indexOf(note);
			currentNotes.splice(idx, 1);
		}
		notesForStruct[totalTime] = currentNotes.slice();

	}
	var geometry = createGeometry(notesForStruct, startTime, totalTime);
	return geometry;
}

function startAnimation() {
	animating = true;
	pausePlayStop();
}

function toggleAnimation() {
	animating = !animating;
}
MIDI.Player.pause(true);
init();
		</script>
		<!-- <script src="js/tonnetz.js" type="text/javascript"></script> -->
	</body>
	</html>
