<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>PB Senior Design</title>
	<!-- fonts -->
	<script src="https://use.typekit.net/snh6agw.js"></script>
	<script>try{Typekit.load({ async: true });}catch(e){}</script>

	<!-- midi.js css -->
	<link href="./css/custom_bootstrap.css" rel="stylesheet" type="text/css" />
	<link href="./css/MIDIPlayer.css" rel="stylesheet" type="text/css" />

	<script src="js/three.min.js" type="text/javascript"></script>
	<script src="js/OrbitControls.js" type="text/javascript"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="js/jquery-3.1.1.min.js" type="text/javascript"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script src="js/bootstrap.min.js" type="text/javascript"></script>
	<script src="js/tween.min.js" type="text/javascript"></script>


	<!-- shim -->
	<script src="MIDI.js/inc/shim/Base64.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/Base64binary.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/WebAudioAPI.js" type="text/javascript"></script>
	<script src="MIDI.js/inc/shim/WebMIDIAPI.js" type="text/javascript"></script>
	<!-- jasmid package -->
	<script src="MIDI.js/inc/jasmid/stream.js"></script>
	<script src="MIDI.js/inc/jasmid/midifile.js"></script>
	<script src="MIDI.js/inc/jasmid/replayer.js"></script>
	<!-- midi.js package -->
	<script src="MIDI.js/js/midi/audioDetect.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/gm.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/loader.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.audiotag.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.webaudio.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/plugin.webmidi.js" type="text/javascript"></script>
	<script src="MIDI.js/js/midi/player.js" type="text/javascript"></script>
	<!-- utils -->
	<script src="MIDI.js/js/util/dom_request_xhr.js" type="text/javascript"></script>
	<script src="MIDI.js/js/util/dom_request_script.js" type="text/javascript"></script>
	<!-- includes -->
	<script src="MIDI.js/examples/inc/timer.js" type="text/javascript"></script>
	<script src="MIDI.js/examples/inc/colorspace.js" type="text/javascript"></script>
	<script src="MIDI.js/examples/inc/event.js" type="text/javascript"></script>

</head>
<body>
	<div class="modal" id="welcomeModal" tabindex="-1" role="dialog">
		<div class="modal-dialog modal-sm" role="document">
			<div class="modal-content">
				<div class="col-xs-12" style="border: 1px solid #00FF88; padding:10%">
					<img style="width:100%" src="images/title.png"><br>
					<h3>Upload a MIDI File to begin</h3>
					<input type='file' accept='audio/midi' onchange='openFile(event)'>
					<p id="loadingMessage" style="color: #00FF88;"></p>
					<p style="color: #DDDDDD;"> Click+drag to rotate</p>
					<p style="color: #DDDDDD;"> Right-click + drag to pan</p>
					<p style="color: #DDDDDD;"> Scroll to zoom</p>

				</div>
			</div>
		</div>
	</div>
	<div id="colors"></div>
	<div>
		<div class="player" style="z-index:4;">
			<div style="margin: 0 auto; width: 160px; float: right;">
				<input type="image" src="images/pause.png" align="absmiddle" value="pause" onclick="pausePlayStop()" id="pausePlayStop">
				<input type="image" src="images/stop.png" align="absmiddle" value="stop" onclick="pausePlayStop(true)">
				<input type="image" src="images/backward.png" align="absmiddle" value="stop" onclick="player.getNextSong(-1);">
				<input type="image" src="images/forward.png" align="absmiddle" value="stop" onclick="player.getNextSong(+1);">
			</div>
			<div class="time-controls">
				<span id="time1" class="time">0:00</span>
				<span id="capsule">
					<span id="cursor"></span>
				</span>
				<span id="time2" class="time" style="text-align: left;">-0:00</span>
			</div>
		</div>
		<!-- <div id="channels"></div> -->
		<div id="colorController">
			<div class="col-xs-12" id="sliders">
				<div class="btn-group btn-group-xs" style="width:100%;" role="group" aria-label="...">
					<button type="button" class="btn btn-default" onclick="resetColorWheel(fifthsOrder)">Circle of Thirds</button>
					<button type="button" class="btn btn-default" data-toggle="modal" data-target="#customOuterRingModal" onclick="pausePlayStop(true)">Custom</button>
				</div>
				<br>
				<!-- <div id="sliders"> -->
				<label class="inputLabel">Outer</label>
				<input type="range" min="0" max="360" class="angleInput" id="primaryAngle"><br>
				<label class="inputLabel">Inner</label>
				<input type="range" min="0" max="360" class="angleInput" id="secondaryAngle"><br>
				<label id="scaleInput" class="inputLabel">Scale</label>
				<input type="range" min="0" max="100" class="angleInput" id="scaleInput"><br>
			</div>
			<div class="col-xs-12">
					<button type="button" id="updateBtn" class="btn btn-success btn-block" onclick="reColorGeometry()">UPDATE</button>

					<label class="mainLabel">Change song:</label>
					<input type='file' accept='audio/midi' onchange='openFile(event)'>
					<img id='output'>
					<p id="loadingMessage2" style="color: #FFFFFF;"></p>
					<br>
					<label class="mainLabel">3D Visualization</label>
					<button type="button" id="singleButton" class="btn btn-danger btn-block" onclick="switchVisualization(0)">Active Mesh</button>
					<div class="col-xs-12" id="singleOptions">
						<input type="checkbox" id="singleWireCheckbox" onclick="showHideStructure()" checked>Show Wifeframe<br>
						<input type="checkbox" id="singleSolidCheckbox" onclick="showHideStructure()" checked>Show Solid Mesh<br>
					</div>
					<button type="button" id="multiButton" class="btn btn-warning btn-block" onclick="switchVisualization(1)">Static Mesh</button>
					<div class="col-xs-12" id="multiOptions">
						<input type="checkbox" id="multiWireCheckbox" onclick="showHideStructure()" checked>Show Wireframe<br>
						<input type="checkbox" id="multiSolidCheckbox" onclick="showHideStructure()" checked>Show Solid Mesh<br>
					</div>
					<button type="button" id="stackButton" class="btn btn-info btn-block" onclick="switchVisualization(2)">Stacked Mesh</button>
					<div class="col-xs-12" id="stackOptions">
						<input type="checkbox" id="stackTonnetzCheckbox" onclick="showHideStructure()" checked>Show Tonnetz<br>
						<input type="checkbox" id="stackNotesCheckbox" onclick="showHideStructure()" checked>Show Notes<br>
					</div><br>
					<label class="mainLabel" style="margin-top: 10px">2D Visualization</label>
					<div class="btn-group btn-group" role="group" aria-label="...">
						<button type="button" class="btn btn-success" onclick="createSongProfile()">Create</button>
						<button type="button" class="btn btn-warning" onclick="removeProfile()">Clear</button>
					</div><br>
				</div>
				<!-- </div> -->
			</div>
			<img id="colorwheel" src="images/colorwheel_hsl.png">
			<!-- <div id="blender"></div> -->

			<!-- <img id="fifthswheel" src="images/circle_fifths_wheel.png"> -->
		</div>
	</div>
	<div class="modal bs-example-modal-sm" id="customOuterRingModal" tabindex="-1" role="dialog" aria-labelledby="mySmallModalLabel">
			  <div class="modal-dialog modal-sm" role="document">
			    <div class="modal-content">
			      <div class="modal-header">
			        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
			        <h4 class="modal-title" id="myModalLabel">Custom Note Order</h4>
			      </div>
			      <div class="modal-body">
			      	<div class="col-xs-5" id="sortableTip">
			      		<p>Drag notes to re-order</p><br>
			      		<label><input type="checkbox" id="outerCheckbox" value="outer_checkbox" checked> Outer Ring</label><br>
			      		<label><input type="checkbox" id="innerCheckbox" value="inner_checkbox" checked> Inner Ring</label><br>
			      	</div>
			      	<div class="col-xs-5">
				      	<ul id="sortable">
								  <li id="0" class="sortNote">C</li>
								  <li id="1" class="sortNote">C#/Db</li>
								  <li id="2" class="sortNote">D</li>
								  <li id="3" class="sortNote">D#/Eb</li>
								  <li id="4" class="sortNote">E</li>
								  <li id="5" class="sortNote">F</li>
								  <li id="6" class="sortNote">F#/Gb</li>
								  <li id="7" class="sortNote">G</li>
								  <li id="8" class="sortNote">G#/Ab</li>
								  <li id="9" class="sortNote">A</li>
								  <li id="10" class="sortNote">A#/Bb</li>
								  <li id="11" class="sortNote">B</li>
								</ul>
							</div>
							<div class="col-xs-2">
								<img id="sortableGradient" src="images/colorGradient.png">
							</div>
			      </div>
			      <div class="modal-footer">
			        <button type="button" class="btn btn-default btn-sm" data-dismiss="modal">Close</button>
			        <button type="button" class="btn btn-primary btn-sm" onclick="customRing()">Save</button>
			      </div>
			    </div>
			  </div>
			</div>
	<div id="canvas"></div>

<script type="text/javascript">
	if (typeof (console) === "undefined") var console = {
		log: function() {}
	};

	$( function() {
    $( "#sortable" ).sortable();
    $( "#sortable" ).disableSelection();
  } );

	// Threejs
	var scene, camera, renderer, noteVertices, vertexColors, vertexKey, vertexColorCache, gColorMap;

	// camera movement
	var animationInterval = 0;
	var animating = false;
	var songTicks = 0;
	var uploadedMidiFile;
	var visScale = 1;
	var singleTonnetz = true;
	var multiTonnetz = false;

	var singleMesh;
	var singleSolidMesh;
	var verticesToMove = [];

	var primaryColors, secondaryColors;

	var primaryHolder, secondaryHolder;
	var noteToString = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
	var fifthsOrder = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];
	var currentNoteOrder = fifthsOrder;

		var secondaryColors = { //offset by half from primary for testing
			
			0: [ 270, 100, 50 ], // 9 A
			1: [ 120, 100, 60 ], // 4 E
			2: [ 330, 100, 46 ], // 11 B 
			3: [ 180, 100, 34 ], // 6 Gb
			4: [ 30, 100, 51 ], // 1 Db
			5: [ 240, 100, 27 ], // 8 Ab
			6: [ 90, 100, 60 ], // 3 Eb
			7: [ 300, 100, 37 ], // 10 Bb
			8: [ 150, 100, 32 ], // 5 F
			9: [ 0, 100, 51 ], // 0 C
			10: [ 210, 100, 28 ], // 7 G
			11: [ 60, 100, 52 ] // 2 D
		};

	function loadRemote(path, callback) {
			var fetch = new XMLHttpRequest();
			fetch.open('GET', path);
			fetch.overrideMimeType("text/plain; charset=x-user-defined");
			fetch.onreadystatechange = function() {
				if(this.readyState == 4 && this.status == 200) {
					/* munge response into a binary string */
					var t = this.responseText || "" ;
					var ff = [];
					var mx = t.length;
					var scc= String.fromCharCode;
					for (var z = 0; z < mx; z++) {
						ff[z] = scc(t.charCodeAt(z) & 255);
					}
					callback(ff.join(""));
				}
			}
			fetch.send();
		}


	function setup() {
		noteVertices = new Array(7);
		for (var i = 0; i < 7; i++) {
		  	noteVertices[i] = new Array(6);
		}
		var noteOrder = [7, 11, 3, 2, 6, 10, 9, 1, 5];
		var nIdx = 0;

		for (var x = 0; x < 3; x++) {
			for (var y = 0; y < 3; y++) {
				var note = noteOrder[nIdx];
				noteVertices[x][y] = note;
				noteVertices[x][y + 3] = note;
				noteVertices[x + 4][y + 2] = note;
				noteVertices[x + 4][(y + 5) % 6] = note;
				nIdx++;
			}
		}
		noteVertices[3][0] = 4;
		noteVertices[3][3] = 4;
		noteVertices[3][1] = 8;
		noteVertices[3][4] = 8;
		noteVertices[3][2] = 0;
		noteVertices[3][5] = 0;

		vertexKey = [];
	}

	setup();

	////// D3 Rotating input functionality
	var wheelWidth = 200;
	var wheelHeight = 200;
	var wheelX = 0;
	var wheelY = 0;

	primaryHolder = d3.select("body")
	.append("svg")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("class", "colorInput");

	primaryHolder.append("image")
	.attr("xlink:href", "images/circle_fifths_wheel.png")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("x", wheelX)
	.attr("y", wheelY);

	secondaryHolder = d3.select("body")
	.append("svg")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("class", "colorInput");

	secondaryHolder.append("image")
	.attr("xlink:href", "images/circle_fifths_wheel_minor.png")
	.attr("width", wheelWidth)    
	.attr("height", wheelHeight)
	.attr("x", wheelX)
	.attr("y", wheelY);


	// when the input range changes update the angle 
	d3.select("#primaryAngle").on("input", function() {
		updateAngle(+this.value, 0);
	});

	d3.select("#secondaryAngle").on("input", function() {
		updateAngle(+this.value, 1);
	});

	d3.select("#scaleInput").on("input", function() {
		updateScale(+this.value);
	});

	updateAngle(0,0);
	updateAngle(0,1);
	// set default colors
	resetColorWheel(fifthsOrder);


function init() {

	$('#welcomeModal').modal('show');

	$('#singleOptions').hide();
	$('#multiOptions').hide();
	$('#stackOptions').show();

	resetColorWheel(fifthsOrder);
	scene = new THREE.Scene();
	var WIDTH = 0.8*window.innerWidth,
	    HEIGHT = window.innerHeight;

	container = document.getElementById('canvas');
	document.body.appendChild( container );

	renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(WIDTH, HEIGHT);
	container.appendChild( renderer.domElement );

  camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 20000);
  camera.position.set(532, -500, 100);
//     {x: 0.06789925799970922, y: 0.8399987615915472, z: -0.5383231084649841}
// (index):247 q {x: 532.3324120127733, y: -505.8011184302427, z: 413.26422056914737}
	camera.up = new THREE.Vector3(0,0,1);
  var dir = new THREE.Vector3(0.86789925799970922, 0.8399987615915472, -0.5383231084649841);
  var pos = new THREE.Vector3(532, -505, 413);
	camera.lookAt(140,100,0);
	camera.name = "camera";

  scene.add(camera);
  

  window.addEventListener('resize', function() {
    var WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;
    renderer.setSize(WIDTH, HEIGHT);
    camera.aspect = WIDTH / HEIGHT;
    camera.updateProjectionMatrix();
  });

  var light = new THREE.PointLight(0xffffff);
  light.position.set(-100,200,100);
  scene.add(light);

 	var geometry = new THREE.Geometry(); 

 	var colorMap = mapColorsToVertices();

	var planeGeometry = new THREE.PlaneGeometry( 4000, 20);
	var planeMaterial = new THREE.MeshBasicMaterial( {color: 0xffffff, transparent: true, side: THREE.DoubleSide} );
	planeMaterial.opacity = 0.5;
	var plane = new THREE.Mesh( planeGeometry, planeMaterial );
	plane.name = "plane";
	scene.add( plane );

	// var srcmidifile = 'music/triads.mid';

	// loadRemote(srcmidifile, function(data) {
	// 		uploadedMidiFile = MidiFile(data);
	// });

	controls = new THREE.OrbitControls(camera, renderer.domElement);

	if (singleTonnetz) {
		constructSingleTonnetz(colorMap);
		plane.traverse( function ( object ) { object.visible = false; } );
	}
/*
 	var geometry = buildTonnetzGeometry(colorMap, true);

 	var solidGeometry = buildTonnetzGeometry(colorMap, false);

	var mesh = new THREE.Mesh( geometry, material );

	mesh.name = "tonnetz";
	scene.add(mesh);

	var solidMesh = new THREE.Mesh( solidGeometry, solidMaterial );
	solidMesh.name = "solidMesh";
	scene.add(solidMesh)

	cacheVertexColors(mesh);
*/
	switchVisualization(0);

}

function switchVisualization(id) {
	if (id == 0) {
		singleTonnetz = true;
		multiTonnetz = false;
	}
	else if (id == 1) {
		singleTonnetz = false;
		multiTonnetz = true;
	}
	else {
		singleTonnetz = false;
		multiTonnetz = false;
	}

	var sceneIdx = 0;
	while(scene.children.length > 2){ 
	    if (scene.children[sceneIdx].name == "camera" || scene.children[sceneIdx].name == "plane") {
	    	sceneIdx++;
	    }
	    else {
	    	scene.remove(scene.children[sceneIdx])
	    }; 
	}
	var meshPlane = scene.getObjectByName("plane");
	
	if (singleTonnetz) {
		var colorMap = mapColorsToVertices();
		constructSingleTonnetz(colorMap);
		meshPlane.traverse( function ( object ) { object.visible = false; } );

		$('#singleOptions').show();
		$('#multiOptions').hide();
		$('#stackOptions').hide();
		$('#updateBtn').hide();
		$('#scaleInput').hide();

		$( '#singleButton' ).addClass('active');
		$( '#multiButton' ).removeClass('active');
		$( '#stackButton' ).removeClass('active');
	}
	else if (multiTonnetz) {
		meshPlane.traverse( function ( object ) { object.visible = false; } );
		reColorGeometry();

		$('#singleOptions').hide();
		$('#multiOptions').show();
		$('#stackOptions').hide();
		$('#updateBtn').hide();
		$('#scaleInput').hide();


		$( '#singleButton' ).removeClass('active');
		$( '#multiButton' ).addClass('active');
		$( '#stackButton' ).removeClass('active');

	}
	else {
		meshPlane.traverse( function ( object ) { object.visible = true; } );
		reColorGeometry();

		$('#singleOptions').hide();
		$('#multiOptions').hide();
		$('#stackOptions').show();
		$('#updateBtn').show();
		$('#scaleInput').show();


		$( '#singleButton' ).removeClass('active');
		$( '#multiButton' ).removeClass('active');
		$( '#stackButton' ).addClass('active');

	}
}

function constructSingleTonnetz(colorMap) {
	var parent =  scene.getObjectByName("musicStructure");
	if (parent) scene.remove(parent);
	singleTonnetz = true;

	var material = new THREE.MeshBasicMaterial( { 
		    shading: THREE.FlatShading,
		    vertexColors: THREE.VertexColors,
		    wireframe: true
		});

	var solidMaterial = new THREE.MeshBasicMaterial({
        polygonOffset: true,  
        polygonOffsetUnits: 1,
        polygonOffsetFactor: 1,
        shading: THREE.FlatShading,
        vertexColors: THREE.FaceColors
    });

	var geometry = buildTonnetzGeometry(colorMap, true);

 	var solidGeometry = buildTonnetzGeometry(colorMap, false);

	singleMesh = new THREE.Mesh( geometry, material );

	singleSolidMesh = new THREE.Mesh( solidGeometry, solidMaterial );


	var parent = new THREE.Object3D();
	parent.name = "singleTonnetzStructure"

	var singleWireframe = new THREE.Object3D();
	singleWireframe.name = "singleWireframe";

	var singleSolid = new THREE.Object3D();
	singleSolid.name = "singleSolid";

	singleMesh.name = "tonnetz";
	singleWireframe.add(singleMesh);

	singleSolidMesh.name = "solidMesh";
	singleSolid.add(singleSolidMesh);

	parent.add(singleWireframe);
	parent.add(singleSolid);

	scene.add(parent);

	cacheVertexColors(singleMesh);
	animate();
}

function constructVisualization(type, scale) {
	var songData = buildSongStructure(uploadedMidiFile, scale);

	if (type == 0) { // vertical midi notes

		var midiGeometry = createGeometry(songData, scale);
		var parent = new THREE.Object3D();
		parent.name = "musicStructure";

		var tonnetzStructure = new THREE.Object3D();
		tonnetzStructure.name = "tonnetzStructure"

		var pointMaterial = new THREE.PointsMaterial( { 
			vertexColors: THREE.VertexColors,
			visible: true, 
			size: 10 } )
		var dot = new THREE.Points( midiGeometry.notes, pointMaterial );
		dot.name = "notes";
		var dotStructure = new THREE.Object3D();
		dotStructure.name = "dotStructure";
		dotStructure.add(dot);
		parent.add( dotStructure );

		var meshMaterial = new THREE.MeshBasicMaterial( { 
			    shading: THREE.FlatShading,
			    vertexColors: THREE.VertexColors,
			    wireframe: true
			});
		for (var i = 0; i < midiGeometry.tonnetz.length; i++) {
			var tonnetzMesh = new THREE.Mesh(midiGeometry.tonnetz[i], meshMaterial);
			tonnetzMesh.name = "tonnetzMesh"+i;
			tonnetzStructure.add(tonnetzMesh);
		}
		parent.add(tonnetzStructure);
		scene.add(parent);
	}
	else if (type == 1) { // displaced tonnetz mesh
		var displacedTonnetzGeometry = createDisplacedTonnetzGeometry(songData.noteArray, songData.startTime,songData.totalTime);

		var parent = new THREE.Object3D();
		parent.name = "displacedTonnetzStructure";

		var wireObject = new THREE.Object3D();
		wireObject.name = "multiWireframe"

		var solidObject = new THREE.Object3D();
		solidObject.name = "multiSolid"


		for (var i = 0; i < displacedTonnetzGeometry.tonnetzGeo.length; i++) {
			var tonnetzMesh = displacedTonnetzGeometry.tonnetzGeo[i];
			var solidMesh = displacedTonnetzGeometry.solidGeo[i];
			wireObject.add(tonnetzMesh);
			solidObject.add(solidMesh);

		}
		parent.add(wireObject);
		parent.add(solidObject);
		scene.add(parent);
	}

}

function animate() {
	requestAnimationFrame(animate);

  // Render the scene.
  renderer.render(scene, camera);
  controls.update();

	TWEEN.update();
}

function tweenVertex(v, dz) {

	var vertex = singleMesh.geometry.vertices[v];
	var position = {z: vertex.z};
	var zeroPos = {z : dz};
	var z = vertex.z;
	var tween = new TWEEN.Tween(position).to(zeroPos, 200);

	tween.onUpdate(function() {
		var vertex = singleMesh.geometry.vertices[v];
		singleMesh.geometry.vertices[v].set(vertex.x, vertex.y, position.z);
		singleMesh.geometry.dynamic = true;
		singleMesh.geometry.verticesNeedUpdate = true;

		singleSolidMesh.geometry.vertices[v].set(vertex.x, vertex.y, position.z);
		singleSolidMesh.geometry.dynamic = true;
		singleSolidMesh.geometry.verticesNeedUpdate = true;
	});

	tween.start();

}

// cache vertex hues
function cacheVertexColors(mesh) {
	vertexColorCache = [];
	for (var f = 0; f < mesh.geometry.faces.length; f++) {
		var faceCol = mesh.geometry.faces[ f ].vertexColors[ 0 ].getHSL();
		var h = faceCol.h * 360;
		vertexColorCache.push(h);
	}
}

function updateMesh(mesh, colorOffset) {
	
	if (colorOffset != 0) {
		var cacheCopy = vertexColorCache.slice();

		// 
		for (var i = 0; i < cacheCopy.length; i++) {
			cacheCopy[i] = (cacheCopy[i] + colorOffset) % 360;
			cacheCopy[i] /= 360.0;
		}
		var cIdx = 0;
		for (var f = 0; f < mesh.geometry.faces.length; f++) {
			mesh.geometry.faces[ f ].vertexColors[ 0 ].setHSL(cacheCopy[cIdx], 1.0, 0.5);
			cIdx++;
		}

		mesh.geometry.colorsNeedUpdate = true;
		// animate();
	}
	
}

function buildTonnetzGeometry(colorMap, hasVertexColors) {
	var geometry = new THREE.Geometry();
   	vertexColors = [];
   	vertexKey = [];

   	for (var y = 0; y < 6; y++) {
   		for (var x = 0; x < 7; x++) {
   			var vertex = new THREE.Vector3(100*x + 50*y, 500 - (100*y), 0);
   			geometry.vertices.push(vertex);
   			vertexKey.push(noteVertices[x][y]);
   			var col = HSLArrayToString(colorMap[x][y]);
   			var vertColor = new THREE.Color( col );
   			vertexColors.push(vertColor);
   		}
   	}

   	for (var v = 0; v < geometry.vertices.length - 1; v++) {
   		// first row
   		if ( v < 6 ) {
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			if (hasVertexColors) {
   				face1.vertexColors[0] = vertexColors[v];
					face1.vertexColors[1] = vertexColors[v+1];
					face1.vertexColors[2] = vertexColors[v+7];
   			}
   			else {
   				face1.color.setHSL(0, 0, 0.3);
   			}
   			

				geometry.faces.push( face1 );
   		}
   		// middle rows
   		else if (( v > 6 && v < 13 ) || (v > 13 && v < 20) || (v > 20 && v < 27) || (v > 27 && v < 34)) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face0.vertexColors[0] = vertexColors[v-6];
					face0.vertexColors[1] = vertexColors[v+1];
					face0.vertexColors[2] = vertexColors[v];
				}
				else {
   				face0.color.setHSL(0, 0, 0.3);
   			}

   			geometry.faces.push( face0 );
   			
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face1.vertexColors[0] = vertexColors[v];
					face1.vertexColors[1] = vertexColors[v+1];
					face1.vertexColors[2] = vertexColors[v+7];
				}
				else {
   				face1.color.setHSL(0, 0, 0.3);
   			}

				geometry.faces.push( face1 );
		}
   		else if (v > 34 && v < 41) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			if (hasVertexColors) {
	   			face0.vertexColors[0] = vertexColors[v-6];
					face0.vertexColors[1] = vertexColors[v+1];
					face0.vertexColors[2] = vertexColors[v];
				}
				else {
   				face0.color.setHSL(0, 0, 0.3);
   			}

   			geometry.faces.push( face0 );
   		}
   		else {
   			continue;
   		}
   	}
   	return geometry;
}

function mapColorsToVertices(colorset) {
	if (!colorset) { // default
		colorset  = primaryColors;
	}

	var colorMap = new Array(7);
	for (var i = 0; i < 7; i++) {
	  	colorMap[i] = new Array(6);
	}

	for (var x = 0; x < 7; x++) {
		for (var y = 0; y < 6; y++) {
			var note = noteVertices[x][y];
			colorMap[x][y] = colorset[note];
		}
	}
	gColorMap = colorMap;
	return colorMap;
}


// update the element
function updateAngle(angle, id) {

	if (id == 0) {
		// adjust the text on the range slider
		d3.select("#primaryAngle").property("value", angle);

		// rotate the text
		primaryHolder.select("image") 
		.attr("transform", "rotate(" + angle + "," + (wheelX + wheelWidth/2) + ","+ (wheelY+wheelHeight/2) +")")

	} else {
		d3.select("#secondaryAngle").property("value", angle);
		secondaryHolder.select("image") 
		.attr("transform", "rotate(" + angle + "," + (wheelX + wheelWidth/2) + ","+ (wheelY+wheelHeight/2) +")")
	}
}

function updateScale(scale) {
	visScale = scale/100.0;
}

function setColors(noteOrder) {
	var dAngle = 360/noteOrder.length;
	var colorMap = {};
	for (var n = 0; n < noteOrder.length; n++) {
		var hue = n*dAngle;
		colorMap[noteOrder[n]] = [hue, 100, 50];
	}
	return colorMap;
}

function resetColors(noteOrder) {
	primaryColors = setColors(noteOrder);
	secondaryColors = {};
	for (var i = 0; i < 12; i++) {
		secondaryColors[i] = primaryColors[(i + 3) % 12].slice();
	}
}

function resetColorWheel(noteOrder) {
	resetColors(noteOrder);
	primaryHolder.select("image")
	.attr("xlink:href", "images/circle_fifths_wheel.png")
	secondaryHolder.select("image")
	.attr("xlink:href", "images/circle_fifths_wheel_minor.png")
	updateAngle(0, 0);
	updateAngle(15, 1);
}

// set individual ring and return to 0 rotation
function setColorRing(noteOrder, ring) {
	if (ring == 0) { // primary
		primaryColors = setColors(noteOrder);
		updateAngle(0, 0);
	}
	else { // secondary
		secondaryColors = setColors(noteOrder);
		updateAngle(0, 1);
	}

}

function customRing() {
	var sortedNotes = $( "#sortable" ).sortable( "toArray" );
	var customNoteOrder = [];
	var cRotate = 0;
	for (var i = 0; i < sortedNotes.length; i++) {
		customNoteOrder.push(parseInt(sortedNotes[i]));
		if (parseInt(sortedNotes[i]) == 0) {
			cRotate = i;
		}
	}
	this.currentNoteOrder = customNoteOrder;

	if($("#outerCheckbox").is(':checked')) {
		primaryHolder.select("image")
		.attr("xlink:href", "images/custom_wheel/co"+ cRotate +".png")

		setColorRing(customNoteOrder, 0);

		if ($("#innerCheckbox").is(':checked')) {

			secondaryHolder.select("image")
			.attr("xlink:href", "images/custom_wheel/ci"+ cRotate +".png")

		  setColorRing(customNoteOrder, 1);
		}
	}    
	else if ($("#innerCheckbox").is(':checked')) {

	  secondaryHolder.select("image")
			.attr("xlink:href", "images/custom_wheel/ci"+ cRotate +".png")
		  setColorRing(customNoteOrder, 1);
	}
	else {
		alert('No ring specified! Aborted.');
	}
}

// Toggle between Pause and Play modes.
function pausePlayStop(stop) {
	var d = document.getElementById("pausePlayStop");
	if (stop) {
		MIDI.Player.stop();
		d.src = "images/play.png";
	} else if (MIDI.Player.playing) {
		d.src = "images/play.png";
		MIDI.Player.pause(true);
	} else {
		d.src = "images/pause.png";
		MIDI.Player.resume();
	}
};

eventjs.add(window, "load", function(event) {

	var colors = document.getElementById("colors");
	var colorElements = [];
	var activeNotes = [];

	for (var n = 0; n < 88; n++) {
		var d = document.createElement("div");
		d.className = "keyColor"
		d.innerHTML = MIDI.noteToKey[n + 21];
		var col = parseInt(255 - ((255 / 88) * n));
		var stringNum = col.toString(16);
		if (col < 16) {
			stringNum = "0" + stringNum;
		}
		colorElements.push(d);
		colors.appendChild(d);
		activeNotes.push(0);
	}

	MIDI.loader = new sketch.ui.Timer;
	MIDI.loadPlugin({
		soundfontUrl: "MIDI.js/examples/soundfont/",
		onprogress: function(state, progress) {
			MIDI.loader.setValue(progress * 100);
		},
		onsuccess: function() { 
			/// this is the language we are running in
			/// this sets up the MIDI.Player and gets things going...
			player = MIDI.Player;
			// var channels = [];
			// var channelCount = 0;
			// var channelContainer = document.getElementById("channels");
			// for (var channel in MIDI.channels) {
			// 	var chanDiv = document.createElement("div");
			// 	chanDiv.className = "channel"
			// 	chanDiv.id = "channel" + channelCount;
			// 	chanDiv.innerHTML = "channel " + channelCount;
			// 	channelCount++;
			// 	channelContainer.appendChild(chanDiv);
			// 	channels.push(chanDiv);
			// }
			player.timeWarp = 1; // speed the song is played back
			player.loadFile(song[songid++ % song.length], player.start);
			player.stop();
			// fetch primary and secondary angles
			var pAngleOffset = parseInt(d3.select("#primaryAngle").property("value"));
			var sAngleOffset = parseInt(d3.select("#secondaryAngle").property("value"));

			var offsetColors = getOffsetColors(pAngleOffset, sAngleOffset);
			var allColors = getColorMap(offsetColors);
			// var blendBox = document.getElementById("blender");
			if (singleTonnetz) var mesh = scene.getObjectByName( "tonnetz" );

			var numNotes = 0;
			var currentBar = 0;
			var barColor;
			player.addListener(function(data) {

				var currPOffset = parseInt(d3.select("#primaryAngle").property("value"));
				var currSOffset = parseInt(d3.select("#secondaryAngle").property("value"));

				// if user changes color shift
				if (currPOffset != pAngleOffset || currSOffset != sAngleOffset) {
					pAngleOffset = currPOffset;
					sAngleOffset = currSOffset;
					getOffsetColors(pAngleOffset, sAngleOffset);
					allColors = getColorMap();
					if (singleTonnetz) updateMesh(mesh, pAngleOffset);
				}

				var parent = scene.getObjectByName("musicStructure");
				if (parent) {
					var dz = data.now * (songTicks / data.end);
					parent.position.set( 0, 0, -dz);
				}
				var mesh = scene.getObjectByName( "tonnetz" );
				var solidMesh = scene.getObjectByName("solidMesh");
				var now = 0;
				var note = data.note - 21;
				var d = colorElements[note];
				var colorset;
				if (d) {
					if (data.message === 144) {
						numNotes++;
						if (numNotes > 1) {
							colorset = allColors.secondary;
						}
						else {
							colorset = allColors.primary;
						}
						if (!singleTonnetz && !multiTonnetz) {
							colorset = allColors.primary;
						}
						d.style.background = HSLArrayToString(colorset[note]);
						activeNotes[note] = colorset[note];
						if (singleTonnetz) displaceVertex(singleMesh, singleSolidMesh, note, data.velocity);
					} else {
						numNotes--;
						numNotes = Math.max(numNotes, 0);
						if (numNotes > 0) {
							colorset = allColors.secondary;
						}
						else {
							colorset = allColors.primary;
						}
						if (!singleTonnetz && !multiTonnetz) {
							colorset = allColors.primary;
						}
						d.style.background = "";
						activeNotes[note] = 0;
						if (singleTonnetz)  displaceVertex(singleMesh, singleSolidMesh, note, data.velocity);
						
					}
					var blendColor = blendColors(activeNotes);
					// blendBox.style.background = HSLArrayToString(blendColor);
					if (singleTonnetz) {
						var solidMesh = scene.getObjectByName("solidMesh");
						colorSolidMesh(singleSolidMesh, blendColor);
						updateMesh(mesh, pAngleOffset);
					}
				}

			});
			///
			MIDIPlayerPercentage(player);
		}
	});
});

function colorSolidMesh(mesh, blendColor) {
	if (!blendColor) {
		blendColor = [0, 0, 30];
	}
	var h = blendColor[0] / 360.0;
	var s = blendColor[1] / 100.0;
	var l = blendColor[2] / 100.0;
	for (var f = 0; f < mesh.geometry.faces.length; f++) {
		mesh.geometry.faces[ f ].color.setHSL(h, s, l);
	}
	mesh.geometry.colorsNeedUpdate = true;
}


// highlight active notes
function highlightVertices(activeColors, blendColor, colorset) {
	// copy colorset, appparently this is the fastest way
	var cs = JSON.parse(JSON.stringify(colorset)); 
	if (blendColor[0] < 0) {
		blendColor[0] = (360 + blendColor[0]);
	}
	blendColor[0] = parseInt(blendColor[0]);
	blendColor[1] = parseInt(blendColor[1]);
	blendColor[2] = parseInt(blendColor[2]);

	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			cs[(i + 9) % 12] = blendColor;
		}
	}
	return cs;
}

function displaceVertex(mesh, solidMesh, note, dz) {
	var n = ((note + 9) % 12);

	for (var v = 0; v < vertexKey.length; v++) {
		if (vertexKey[v] == n) {
			var oldVert = mesh.geometry.vertices[v];

			if (singleTonnetz) {
				tweenVertex(v, dz);
			}
			else {
				
				mesh.geometry.vertices[v].set(oldVert.x, oldVert.y, dz);
				mesh.geometry.dynamic = true;
				mesh.geometry.verticesNeedUpdate = true;

				solidMesh.geometry.vertices[v].set(oldVert.x, oldVert.y, dz);
				solidMesh.geometry.dynamic = true;
				solidMesh.geometry.verticesNeedUpdate = true;
			}
		}
	}

}


function buildDisplacementMap(activeColors) {
	var dz = 100;
	var dMap = new Array(7);
	for (var i = 0; i < 7; i++) {
	  	dMap[i] = new Array(6).fill(0);
	}

	var notesToMove = [];
	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			var note = (i + 9) % 12;
			notesToMove.push(note);
		}
	}

	for (var n = 0; n < notesToMove.length; n++) {
		for (var x = 0; x < 7; x++) {
			for (var y = 0; y < 6; y++) {
				if (noteVertices[x][y] == notesToMove[n]) {
					dMap[x][y] = dz;
				}
			}
		}
	}

	return dMap;
}


// blend multiple colors together - raw average
function blendColors(activeColors) {
	var toBlend = [];
	for (var i = 0; i < 88; i++) {
		var col = activeColors[i];
		if (Array.isArray(col) && col.length == 3) {
			toBlend.push(col);
		}
	}
	var numColors = toBlend.length;
	if (!numColors) return "";

	// convert from polar (HSL) coordinates to average color
	var colY = 0;
	var colX = 0;

	var avgS = 0;
	var avgL = 0;

	for (var color = 0; color < numColors; color++) {
		var colorAngle = toBlend[color][0] * Math.PI / 180; // convert to radians
		colY += Math.sin(colorAngle);
		colX += Math.cos(colorAngle);
		avgS += toBlend[color][1];
		avgL += toBlend[color][2];
	}

	var magnitude = Math.sqrt(Math.pow(colY, 2) + Math.pow(colX, 2));
	magnitude /= numColors; // normalize by potential longest length (all tones coincident)
	avgS = Math.min(magnitude*100, 100);
	avgL /= numColors;

	var avgRadAngle = Math.atan2(colY, colX); // new color direction
	var avgColor = avgRadAngle * 180/Math.PI; // convert back to degrees (hue)

	// format for hsl
	var blendedColor = [avgColor, avgS, avgL];
	return blendedColor;
}

function getOffsetColors(pOffset, sOffset) {
	resetColors(currentNoteOrder);
	// add offset
	for (var c = 0; c < 12; c++) {
		var col = primaryColors[c];
		col[0] = (col[0] + pOffset) % 360;
		primaryColors[c] = col;

		var scol = secondaryColors[c];
		scol[0] = (scol[0] + sOffset) % 360;
		secondaryColors[c] = scol;
	}

	var allColors = {};
	allColors.primary = primaryColors;
	allColors.secondary = secondaryColors;
	return allColors;
}

function getColorMap() {
	var primaryNoteColors = {};
	var secondaryNoteColors = {};
	for (var note = 0; note < 88; note++) {

		var pCol = primaryColors[(note + 9) % 12];
		primaryNoteColors[note] = pCol;

		var sCol = secondaryColors[(note + 9) % 12];
		secondaryNoteColors[note] = sCol;
	}

	var allColors = {};
	allColors.primary = primaryNoteColors;
	allColors.secondary = secondaryNoteColors;

	return allColors;
}


function HSLArrayToString(col) {
	if (Array.isArray(col) && col.length == 3) {
		return 'hsl(' + col[0] + ',' + col[1] + '%,' + col[2] + '%)';
	}
	else {
		return 'hsl(0, 0%, 0%)';
	}
}

var numSongs = 0;

var openFile = function(event) {
	$('#loadingMessage').text("loading...");
	$('#loadingMessage2').text("loading...");


  var input = event.target;
  var urlReader = new FileReader();

  urlReader.onload = function(){
    var dataURL = urlReader.result;
    var output = document.getElementById('output');
    output.src = dataURL;
    song = [];
    song.push(dataURL);
    // player.getNextSong(+1);
    numSongs++;


   	loadRemote(dataURL, function(data) {
			uploadedMidiFile = MidiFile(data);
			reColorGeometry();
			$('#welcomeModal').modal('hide');
			$('#loadingMessage').text("");
			$('#loadingMessage2').text("");
			animate();
		});
  };

  urlReader.readAsDataURL(input.files[0]);
}

function MIDIPlayerPercentage(player) {
	// update the timestamp
	var time1 = document.getElementById("time1");
	var time2 = document.getElementById("time2");
	var capsule = document.getElementById("capsule");
	var timeCursor = document.getElementById("cursor");
	//
	eventjs.add(capsule, "drag", function(event, self) {
		eventjs.cancel(event);
		player.currentTime = (self.x) / 420 * player.endTime;
		if (player.currentTime < 0) player.currentTime = 0;
		if (player.currentTime > player.endTime) player.currentTime = player.endTime;
		if (self.state === "down") {
			player.pause(true);
		} else if (self.state === "up") {
			player.resume();
		}
	});
	
	function timeFormatting(n) {
		var minutes = n / 60 >> 0;
		var seconds = String(n - (minutes * 60) >> 0);
		if (seconds.length == 1) seconds = "0" + seconds;
		return minutes + ":" + seconds;
	};
	player.getNextSong = function(n) {
		var id = Math.abs((songid += n) % song.length);
		player.loadFile(song[id], player.start); // load MIDI
	};
	player.setAnimation(function(data, element) {
		var percent = data.now / data.end;
		var now = data.now >> 0; // where we are now
		var end = data.end >> 0; // end of song
		if (now === end) { // go to next song
			var id = ++songid % song.length;
			player.loadFile(song[id], player.start); // load MIDI
		}
		// display the information to the user
		timeCursor.style.width = (percent * 100) + "%";
		time1.innerHTML = timeFormatting(now);
		time2.innerHTML = "-" + timeFormatting(end - now);
	});
};

		// Begin loading indication.
		var player;
		// MIDI files from Disklavier World
		var songid = 0;
		var song = [
	// Test 1
	 'data:audio/midi;base64,TVRoZAAAAAYAAQACAeBNVHJrAAAAdQD/Awh1bnRpdGxlZAD/AihDb3B5cmlnaHQgKGMpIDIwMTIgUHJvc29uaWMgU3R1ZGlvcywgTExDAP9YBAQCGAgA/1kCAAAA/1EDCSfAAP8GBUkgMm5kjwD/BgZJViAxc3SPAP8GAVaPAP8GBUkgMm5kAP8vAE1UcmsAAABuAP8DGVRyaWFkc15NYWpvcl40LTReSSBJViBJIFYAkEdqAENqAD5rjnFDAAU+AABHAAZIagFDawNAbo52QAAAQwAASAAFRWoFQm4APm6OcT4ABUIAAEUABz5sA0NuAkdwjnRHAABDAAA+AAD/LwA=',
	// Test 2
	// 'data:audio/mid;base64,TVRoZAAAAAYAAQABAMBNVHJrAAAAVwD/WAQEAhgIAP9RAwehIAD/AwlOZXcgVHJhY2sAwAAAkDxkgRCAPDAwkDxkgRCAPDAwkDxkAJBAZACQQ2SBEIA8MACAQDAAgEMwMJA8ZIE/gDwwJv8vAA==',
	// Test 3
//		'data:audio/mid;base64,TVRoZAAAAAYAAQABAMBNVHJrAAAAXwD/WAQEAhgIAP9RAwehIAD/AwlOZXcgVHJhY2sAwAAAkDxkgRCAPDAwkDxkgRCAPDAwkDxkAJBAZACQQ2QHkEhkgQmAPDAAgEAwAIBDMACASDAwkDxkgT+APDAm/y8A',

	//'data:audio/mid;base64,TVRoZAAAAAYAAQACAeBNVHJrAAAAnwD/Awh1bnRpdGxlZAD/AihDb3B5cmlnaHQgKGMpIDIwMTIgUHJvc29uaWMgU3R1ZGlvcywgTExDAP9YBAwDDAgA/1kCAAAA/1EDCSfAAP8GBUkgMm5khVD/BgQtVklJkHD/BgZ2aSAxc3SFUP8GBC1WSUmQcP8GBUkgMm5khVD/BgQtVklJkHD/BgZ2aSAxc3SFUP8GBVYgMXN0AP8vAE1UcmsAAADNAP8DLFRyaWFkc15NYWpvcl4xMi04XkkgLVZJSSB2aSAtVklJIEkgLVZJSSB2aSBWAZBAeQBEeQI7eoVCOwAARAAAQAAHRWsEPm4BQm6QZEIAAD4AAEUAB0l0AUB2AUR2hUdEAABAAABJAAdFawRCbgM+cJBiPgAAQgAARQAKO3cBQHgDRHqFQkQAAEAAADsABUJpAUVqAT5rkGk+AABFAABCAAZJdABEdAhAeoVCQAAARAAASQAIP2sCR20BQm6QZUIAAEcAAD8AAP8vAA==',
	];

// construct template tonnetz geometry for stack
function buildTemplateTonnetzGeometry(time, notes, octave) {
	var geometry = new THREE.Geometry();
   	vertexColors = [];
   	vertexKey = [];

   	var activeColors = [];
   	for (var i = 0; i < notes.length; i++) {
   		activeColors[notes[i]] = (primaryColors[notes[i] % 12]);
   	}
   	var blendColor = blendColors(activeColors);
   	if (blendColor[0] < 0) {
			blendColor[0] = (360 + blendColor[0]);
		}
   	blendColor[0] = parseInt(blendColor[0]);
		blendColor[1] = parseInt(blendColor[1]);
		blendColor[2] = parseInt(blendColor[2]);

   	var mag = 40;
   	var octaveShift = Math.floor(octave) * 6 * mag - (6 * mag * 3);
   	var col = HSLArrayToString(blendColor);
   	var vertColor = new THREE.Color( col );

   	for (var y = 0; y < 6; y++) {
   		for (var x = 0; x < 7; x++) {
   			var vertex = new THREE.Vector3(mag*x + mag*0.5*y + octaveShift, mag*5 - (mag*y), time);
   			geometry.vertices.push(vertex);
   			vertexKey.push(noteVertices[x][y]);
   			// var col = HSLArrayToString(gColorMap[x][y]);

   			vertexColors.push(vertColor);
   		}
   	}

   	for (var v = 0; v < geometry.vertices.length - 1; v++) {
   		// first row
   		if ( v < 6 ) {
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
 				face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];
   			

				geometry.faces.push( face1 );
   		}
   		// middle rows
   		else if (( v > 6 && v < 13 ) || (v > 13 && v < 20) || (v > 20 && v < 27) || (v > 27 && v < 34)) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];

   			geometry.faces.push( face0 );
   			
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];


				geometry.faces.push( face1 );
		}
   		else if (v > 34 && v < 41) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];


   			geometry.faces.push( face0 );
   		}
   		else {
   			continue;
   		}
   	}
  return geometry;
}

function removeProfile() {
	$( "#profileCanvas" ).remove();
}

function createSongProfile() {
	var songData = buildSongStructure(uploadedMidiFile, 1);
	var profileArray = getProfileArray(songData);

	var numBars = profileArray.length;

	var x = 0;
	var y = 0;
	var width = 1;
	var height = window.innerHeight;

	// create canvas
	var canvas = document.createElement('div');
	canvas.id = "profileCanvas";
	//Set canvas width/height
	canvas.style.width=(window.innerWidth - 200) + "px";
	canvas.style.height='90%';
	//Set canvas drawing area width/height
	// canvas.width = window.innerWidth;
	// canvas.height = window.innerHeight;
	//Position canvas
	canvas.style.position='absolute';
	canvas.style.left=0;
	canvas.style.top=0;
	canvas.style.zIndex=4;
	canvas.style.margin="0px 0px 0px 200px";
	// canvas.style.pointerEvents='none';
	document.body.appendChild(canvas);
	// var context = canvas.getContext('2d');

	var dx = (window.innerWidth - 200)/songData.totalTime;
	// draw rectangles
	for (var i = 0; i < profileArray.length; i++) {
		var colObj = profileArray[i];
		var nextTime;
		if (i < profileArray.length - 1) {
			nextTime = profileArray[i + 1].time;
		}
		else {
			nextTime = songData.totalTime;
		}
		width = (nextTime - colObj.time) * dx;
		// context.rect(x, y, width, height);
		// context.fillStyle = colObj.color;
		// context.fill();

		var div = document.createElement("div");
		div.className="profileBar";
		div.id="bar"+i;
		div.style.width = width + "px";
		div.style.height = height + "px";
		div.style.background = colObj.color;
		div.style.position="absolute";
		div.style.margin = "0px 0px 0px " + x + "px";

		var popup = document.createElement("div");
		popup.id="bar"+i+"popup";
		popup.style.width = "80px";
		// popup.style.height = "50px";
		popup.style.background = 'black';
		popup.style.color = 'white';
		popup.style.position="absolute";
		popup.style.margin = "30% 0px 0px " + x + "px";
		popup.style.display = 'none';
		popup.style.zIndex = 5;


		var colorSize = 25;
		for (var n = 0; n < colObj.noteStrings.length; n++) {
			var colorDiv = document.createElement("div");
			colorDiv.className="col-xs-12";
			colorDiv.style.padding="2px";
			var color = document.createElement("div");
			// color.style.width = colorSize + "px";
			// color.style.height = colorSize + "px";
			color.className = "col-xs-7";
			color.style.height = "100%";
			color.style.padding = "9px";
			color.style.background = colObj.noteColors[n];

			var noteDiv = document.createElement("div");
			noteDiv.className = "col-xs-5"
			noteDiv.innerHTML = colObj.noteStrings[n];

			colorDiv.appendChild(color);
			colorDiv.appendChild(noteDiv);


			popup.appendChild(colorDiv);
		}

		document.getElementById("profileCanvas").appendChild(div);
		document.getElementById("profileCanvas").appendChild(popup);
		x += width;
	}
	
	$(function () {
    $(".profileBar").hover(function () {
      var barId = $(this).attr('id');
	    var popup = '#' + barId + 'popup';
	    $(popup).toggle();
    });
	});
}




// color profile of song
function getProfileArray(songData) {
	var noteArray = songData.noteArray;
	var startTime = songData.startTime;
	var totalTime = songData.totalTime;
	var notes;
	var blendColor;
	var profile = [];
	var prevNotes = [];

 	for (var t = startTime; t < totalTime; t++) {
 		var position = (t - startTime);
 		if (noteArray[t]) {
 			notes = noteArray[t];
 			var changed = false;
 			for (var n = 0; n < notes.length; n++) {
 				if (prevNotes.indexOf(notes[n]) < 0) {
 					changed = true;
 					break;
 				}
			}
			prevNotes = notes;
			if (changed) {
				var activeColors = [];
				var noteColors = [];
				var noteStrings = [];
		   	for (var i = 0; i < notes.length; i++) {
		   		activeColors[notes[i]] = (primaryColors[notes[i] % 12]);
		   		noteColors.push(HSLArrayToString(primaryColors[notes[i] % 12]));
		   		noteStrings.push(noteToString[notes[i] % 12]);
		   	}

		   	blendColor = blendColors(activeColors);
		   	if (blendColor[0] < 0) {
					blendColor[0] = (360 + blendColor[0]);
				}
		   	blendColor[0] = parseInt(blendColor[0]);
				blendColor[1] = parseInt(blendColor[1]);
				blendColor[2] = parseInt(blendColor[2]);

		   	var col = HSLArrayToString(blendColor);
		   	var colObj = {color: col, time : t};
		   	colObj.noteColors = noteColors;
		   	colObj.noteStrings = noteStrings;
		   	profile.push(colObj);

			}
	 	}
 		if (!notes) continue;
 	}
 	return profile;

}

// convert array to threejs vertices for point cloud rendering
// stack visualization
function createGeometry(songData, scale) {

	var noteArray = songData.noteArray;
	var startTime = songData.startTime;
	var totalTime = songData.totalTime;

	var geometry = new THREE.Geometry();
	var tonnetzGeo = [];
	var notes;
	var result = {};
	var mag = 40;
	var localZPos;
	var prevNotes = [];

 	for (var t = startTime; t < totalTime; t++) {
 		var zPos = (t - startTime) * scale;
 		if (noteArray[t]) {
 			localZPos = 0;
 			notes = noteArray[t];
 			var activeOctaves = [];
 			for (var n = 0; n < notes.length; n++) {
 				if (prevNotes.indexOf(notes[n]) >= 0) continue; // only build tonnetz for new notes 
				var noteOct = Math.floor(notes[n] / 12);
				if (activeOctaves.indexOf(noteOct) < 0) {
					activeOctaves.push(noteOct);
				}
			}
			prevNotes = notes;
			for (var o = 0; o < activeOctaves.length; o++) {
 					var singleTon = buildTemplateTonnetzGeometry(zPos, notes, activeOctaves[o]);
 					tonnetzGeo.push(singleTon);
 			}
 			
 		}
 		if (!notes) continue;
		// var notes = noteArray[eventTime];
		for (var n = 0; n < notes.length; n++) {
			var note = notes[n];
 			for (var x = 0; x < 7; x++) {
				for (var y = 0; y < 6; y++) {
					if (noteVertices[x][y] == (note % 12)) {
						octaveShift = (Math.floor(note / 12) * 6*mag) - (6*mag*3);
						// console.log("octave 1: " + Math.floor(note/12) + " shift " + octaveShift);
						// octaveShift = 0;
						var vertex = new THREE.Vector3(mag*x + mag*0.5*y + octaveShift, mag*5 - (mag*y), zPos);
						// var vertex = new THREE.Vector3(x, y, 0);
						geometry.vertices.push(vertex);

						// fade colors by length of note strike
						var colArray = primaryColors[note % 12].slice();
						colArray[2] = parseInt(Math.max((2000 - localZPos)/2000, 0)*50);
						var col = HSLArrayToString(colArray);
   					var vertColor = new THREE.Color( col );
   					geometry.colors.push(vertColor);
					}
				}
			}
 		}
 		localZPos++;
 	}
 	result.notes = geometry;
 	result.tonnetz = tonnetzGeo;

 	return result;
}

function buildDisplacedTonnetz(notes) {
	var geometry = new THREE.Geometry();
   	vertexColors = [];
   	vertexKey = [];

   	var activeColors = [];
   	for (var i = 0; i < notes.length; i++) {
   		activeColors[notes[i]] = (primaryColors[notes[i] % 12]);
   	}
   	var blendColor = blendColors(activeColors);
   	if (blendColor[0] < 0) {
			blendColor[0] = (360 + blendColor[0]);
		}
   	blendColor[0] = parseInt(blendColor[0]);
		blendColor[1] = parseInt(blendColor[1]);
		blendColor[2] = parseInt(blendColor[2]);

   	var mag = 40;
   	var octaveShift = Math.floor(octave) * 6 * mag - (6 * mag * 3);
   	// console.log("octave 2: " + Math.floor(octave) + " shift " + octaveShift);

   	for (var y = 0; y < 6; y++) {
   		for (var x = 0; x < 7; x++) {
   			var vertex = new THREE.Vector3(mag*x + mag*0.5*y + octaveShift, mag*5 - (mag*y), time);
   			geometry.vertices.push(vertex);
   			vertexKey.push(noteVertices[x][y]);
   			// var col = HSLArrayToString(gColorMap[x][y]);
   			var col = HSLArrayToString(blendColor);
   			var vertColor = new THREE.Color( col );
   			vertexColors.push(vertColor);
   		}
   	}

   	for (var v = 0; v < geometry.vertices.length - 1; v++) {
   		// first row
   		if ( v < 6 ) {
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
 				face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];
   			
				geometry.faces.push( face1 );
   		}
   		// middle rows
   		else if (( v > 6 && v < 13 ) || (v > 13 && v < 20) || (v > 20 && v < 27) || (v > 27 && v < 34)) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];

   			geometry.faces.push( face0 );
   			
   			var face1 = new THREE.Face3( v, v+1, v+7 );
   			face1.normal.set(0,0,1);
   			face1.vertexColors[0] = vertexColors[v];
				face1.vertexColors[1] = vertexColors[v+1];
				face1.vertexColors[2] = vertexColors[v+7];


				geometry.faces.push( face1 );
		}
   		else if (v > 34 && v < 41) {
   			var face0 = new THREE.Face3( v-6, v+1, v);
   			face0.normal.set(0,0,1);
   			face0.vertexColors[0] = vertexColors[v-6];
				face0.vertexColors[1] = vertexColors[v+1];
				face0.vertexColors[2] = vertexColors[v];


   			geometry.faces.push( face0 );
   		}
   		else {
   			continue;
   		}
   	}
  return geometry;
}

// convert array to threejs vertices for point cloud rendering

// multi visualization
function createDisplacedTonnetzGeometry(noteArray, startTime, totalTime) {
	var colorMap = mapColorsToVertices();

	var results = {};
	var tonnetzGeo = [];
	var solidGeo = [];
	var notes;


	var material = new THREE.MeshBasicMaterial( { 
    shading: THREE.FlatShading,
    vertexColors: THREE.VertexColors,
    wireframe: true
		});

	var solidMaterial = new THREE.MeshBasicMaterial({
    polygonOffset: true,  
    polygonOffsetUnits: 1,
    polygonOffsetFactor: 1,
    shading: THREE.FlatShading,
    vertexColors: THREE.FaceColors
  });
	var xPos = 0;
	var dX = -600;

 	for (var t = startTime; t < totalTime; t++) {
 		if (noteArray[t] && notes != noteArray[t]) {
 			notes = noteArray[t];
 		}
 		else {
 			continue;
 		}

		var tGeometry = buildTonnetzGeometry(colorMap, true);
	 	var solidGeometry = buildTonnetzGeometry(colorMap, false);

	 	tGeometry.translate(xPos, 0, 0);
	 	solidGeometry.translate(xPos, 0, 0);

	 	xPos += dX;


	 	// color solid underlying mesh as the blended color
	 	var activeColors = [];
   	for (var i = 0; i < notes.length; i++) {
   		activeColors[notes[i]] = (primaryColors[notes[i] % 12]);
   	}
   	var blendColor = blendColors(activeColors);
   	if (blendColor[0] < 0) {
			blendColor[0] = (360 + blendColor[0]);
		}
   	blendColor[0] = parseInt(blendColor[0]);
		blendColor[1] = parseInt(blendColor[1]);
		blendColor[2] = parseInt(blendColor[2]);

		var mesh = new THREE.Mesh( tGeometry, material );
		var solidMesh = new THREE.Mesh( solidGeometry, solidMaterial );

		colorSolidMesh(solidMesh, blendColor);

		for (var n = 0; n < notes.length; n++) {
			var note = notes[n];
			displaceVertex(mesh, solidMesh, note, 128);
 		}

 		tonnetzGeo.push(mesh);
 		solidGeo.push(solidMesh)

 	}
 	results.tonnetzGeo = tonnetzGeo;
 	results.solidGeo = solidGeo;
 	return results;
}

// construct main structure of song
function buildSongStructure(midifile, scale) {
	var header = midifile.header;
	var tracks = midifile.tracks;

	var events = tracks[1];

	var totalTime = 0;
	var notesForStruct = {};
	var currentNotes = [];
	var startTime = -1;

	// if event contains 'noteOn' or 'noteOff' subtypes, add note to an object for each time that an event occurs
	for (var e = 0; e < events.length; e++) {
		var noteEvent = events[e];
		if (noteEvent.type != "channel" || (noteEvent.subtype != "noteOn" && noteEvent.subtype != "noteOff")) continue;
		totalTime += noteEvent.deltaTime;
		var note = noteEvent.noteNumber;
		if (noteEvent.subtype == "noteOn") {
			currentNotes.push(note);
			if (startTime == -1) startTime = totalTime;
		}
		else if(noteEvent.subtype == "noteOff") {
			var idx = currentNotes.indexOf(note);
			currentNotes.splice(idx, 1);
		}
		notesForStruct[totalTime] = currentNotes.slice();

	}
	songTicks = totalTime * scale;
	var songData = {};
	songData.noteArray = notesForStruct;
	songData.startTime = startTime;
	songData.totalTime = totalTime;
	return songData;
}

function reColorGeometry() {
	if (!singleTonnetz && !multiTonnetz) {
		var parent =  scene.getObjectByName("musicStructure");
		if (parent) scene.remove(parent);
		constructVisualization(0, visScale);
	}
	else if (multiTonnetz) {
		var parent =  scene.getObjectByName("displacedTonnetzStructure");
		if(parent) scene.remove(parent);
		constructVisualization(1, visScale);
	}
}

function showHideStructure() {
	if (singleTonnetz) {

		var wObject = scene.getObjectByName('singleWireframe', true);
		var sObject = scene.getObjectByName('singleSolid', true);

		if($("#singleWireCheckbox").is(':checked')) {
			wObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			wObject.traverse( function ( object ) { object.visible = false; } );
		} 

		if($("#singleSolidCheckbox").is(':checked')) {
			sObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			sObject.traverse( function ( object ) { object.visible = false; } );
		} 


	}
	else if (multiTonnetz) {

		var wObject = scene.getObjectByName('multiWireframe', true);
		var sObject = scene.getObjectByName('multiSolid', true);

		if($("#multiWireCheckbox").is(':checked')) {
			wObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			wObject.traverse( function ( object ) { object.visible = false; } );
		} 

		if($("#multiSolidCheckbox").is(':checked')) {
			sObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			sObject.traverse( function ( object ) { object.visible = false; } );
		} 

	}
	else {
		var tObject = scene.getObjectByName('tonnetzStructure', true);
		var nObject = scene.getObjectByName('dotStructure', true);

		if($("#stackTonnetzCheckbox").is(':checked')) {
			tObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			tObject.traverse( function ( object ) { object.visible = false; } );
		} 

		if($("#stackNotesCheckbox").is(':checked')) {
			nObject.traverse( function ( object ) { object.visible = true; } );
		}
		else {
			nObject.traverse( function ( object ) { object.visible = false; } );
		} 
	}
	


	

}


function startAnimation() {
	animating = true;
	// pausePlayStop();
}

function toggleAnimation() {
	animating = !animating;
}

init();
		</script>
		<!-- <script src="js/tonnetz.js" type="text/javascript"></script> -->
	</body>
	</html>
